pynamics_to_control

>>> import numpy as np
>>> import control as ct
>>> from pynamics.models.state_space_models import LinearModel
>>> from pynamics.models.model_conversion import pynamics_to_control
>>>
>>> A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);
>>> B = np.array([1, -5, 1]).reshape(-1, 1);
>>> C = np.array([0, 0, 1]);
>>> D = np.array([0]);
>>> py_model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);
>>>
>>> ct_model = pynamics_to_control(py_model);
>>> isinstance(ct_model, ct.statesp.StateSpace)
True
>>>
>>> ct_model.A
array([[ 0.,  0., -1.],
       [ 1.,  0., -3.],
       [ 0.,  1., -3.]])
>>>
>>> ct_model.B
array([[ 1.],
       [-5.],
       [ 1.]])
>>>
>>> ct_model.C
array([[0., 0., 1.]])
>>>
>>> ct_model.D
array([[0.]])

control_to_pynamics

>>> import numpy as np
>>> import control as ct
>>> import pynamics as pyn
>>> from pynamics.models.model_conversion import control_to_pynamics
>>>
>>> A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);
>>> B = np.array([1, -5, 1]).reshape(-1, 1);
>>> C = np.array([0, 0, 1]);
>>> D = np.array([0]);
>>> ct_model = ct.ss(A, B, C, D);
>>>
>>> py_model = control_to_pynamics(ct_model, initial_state=np.zeros((3, 1)), initial_control=np.zeros((1, 1)));
>>> isinstance(py_model, pyn.models.state_space_models.LinearModel)
True
>>>
>>> py_model.A
array([[ 0.,  0., -1.],
       [ 1.,  0., -3.],
       [ 0.,  1., -3.]])
>>>
>>> py_model.B
array([[ 1.],
       [-5.],
       [ 1.]])
>>>
>>> py_model.C
array([[0., 0., 1.]])
>>>
>>> py_model.D
array([[0.]])

Linear model -> get state

>>> import numpy as np
>>> from pynamics.models.state_space_models import LinearModel
>>>
>>> A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);
>>> B = np.array([1, -5, 1]).reshape(-1, 1);
>>> C = np.array([0, 0, 1]);
>>> D = np.array([0]);
>>> model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);
>>>
>>> model.get_state() 
array([[0.],
       [0.],
       [0.]])

Linear model -> get output

>>> import numpy as np
>>> from pynamics.models.state_space_models import LinearModel
>>>
>>> A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);
>>> B = np.array([1, -5, 1]).reshape(-1, 1);
>>> C = np.array([0, 0, 1]);
>>> D = np.array([0]);
>>> model = LinearModel(np.ones((3, 1)), np.zeros((1, 1)), A, B, C, D);
>>>
>>> model.get_output()
array([[1.]])

Linear model -> get input

>>> import numpy as np
>>> from pynamics.models.state_space_models import LinearModel
>>>
>>> A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);
>>> B = np.array([1, -5, 1]).reshape(-1, 1);
>>> C = np.array([0, 0, 1]);
>>> D = np.array([0]);
>>> model = LinearModel(np.zeros((3, 1)), np.ones((1, 1)), A, B, C, D);
>>>
>>> model.get_input()
array([[1.]])

Linear model -> set input

>>> import numpy as np
>>> from pynamics.models.state_space_models import LinearModel
>>>
>>> A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);
>>> B = np.array([1, -5, 1]).reshape(-1, 1);
>>> C = np.array([0, 0, 1]);
>>> D = np.array([0]);
>>> model = LinearModel(np.zeros((3, 1)), np.ones((1, 1)), A, B, C, D);
>>>
>>> model.get_input()
array([[1.]])
>>>
>>> model.set_input(np.array([[5.0]]));
>>> model.get_input()
array([[5.]])

For single-input systems, floats and integers also constitute valid inputs:

>>> model.set_input(2.5);
>>> model.get_input()
array([[2.5]])

Linear model -> update state

>>> import numpy as np
>>> from pynamics.models.state_space_models import LinearModel
>>>
>>> A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);
>>> B = np.array([1, -5, 1]).reshape(-1, 1);
>>> C = np.array([0, 0, 1]);
>>> D = np.array([0]);
>>> model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);
>>> 
>>> model.get_state()
array([[0.],
       [0.],
       [0.]])
>>>
>>> model.update_state(np.ones((3, 1)));
>>> model.get_state()
array([[1.],
       [1.],
       [1.]])

Linear model -> eval

>>> import numpy as np
>>> from pynamics.models.state_space_models import LinearModel
>>>
>>> A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);
>>> B = np.array([1, -5, 1]).reshape(-1, 1);
>>> C = np.array([0, 0, 1]);
>>> D = np.array([0]);
>>> model = LinearModel(np.ones((3, 1)), np.zeros((1, 1)), A, B, C, D);
>>>
>>> model.eval(0.0, x=model.get_state())
array([[-1.],
       [-2.],
       [-2.]])

Nonlinear model -> get state

>>> import numpy as np
>>> from pynamics.models.state_space_models import NonlinearModel
>>>
>>> # Define the state function.
>>> def state_function(state: np.ndarray, control: np.ndarray, time: float):
...
...    state_derivative_1 = state[0] + 2 * np.cos(state[1]);
...    state_derivative_2 = state[1] + control[0];
...    state_derivative = np.array([state_derivative_1, state_derivative_2]);
...
...    return state_derivative;   
>>>
>>> # Define the output function.
>>> def output_function(state: np.ndarray):
...
...    output = np.array([state[0]**state[1]]);
...
...    return output;
>>>
>>> model = NonlinearModel(np.zeros((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);
>>>
>>> model.get_state()
array([[0.],
       [0.]])

Nonlinear model -> get output

>>> import numpy as np
>>> from pynamics.models.state_space_models import NonlinearModel
>>>
>>> # Define the state function.
>>> def state_function(state: np.ndarray, control: np.ndarray, time: float):
...
...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);
...     state_derivative_2 = state[1] + control[0];
...     state_derivative = np.array([state_derivative_1, state_derivative_2]);
...
...     return state_derivative;   
>>>
>>> # Define the output function.
>>> def output_function(state: np.ndarray):
...
...     output = np.array([state[0]**state[1]]);
...
...     return output;
>>>
>>> model = NonlinearModel(np.ones((2, 1)), np.zeros((1, 1)), state_function, output_function, input_dim=2, output_dim=1);
>>>
>>> model.get_output()
array([[1.]])

Nonlinear model -> get input

>>> import numpy as np
>>> from pynamics.models.state_space_models import NonlinearModel
>>>
>>> # Define the state function.
>>> def state_function(state: np.ndarray, control: np.ndarray, time: float):
...
...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);
...     state_derivative_2 = state[1] + control[0];
...     state_derivative = np.array([state_derivative_1, state_derivative_2]);
...
...     return state_derivative;   
>>>
>>> # Define the output function.
>>> def output_function(state: np.ndarray):
...
...     output = np.array([state[0]**state[1]]);
...
...     return output;
>>>
>>> model = NonlinearModel(np.ones((2, 1)), 2.5 * np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);
>>>
>>> model.get_input()
array([[2.5]])

Nonlinear model -> set input

>>> import numpy as np
>>> from pynamics.models.state_space_models import NonlinearModel
>>>
>>> # Define the state function.
>>> def state_function(state: np.ndarray, control: np.ndarray, time: float):
...
...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);
...     state_derivative_2 = state[1] + control[0];
...     state_derivative = np.array([state_derivative_1, state_derivative_2]);
...
...     return state_derivative;   
>>>
>>> # Define the output function.
>>> def output_function(state: np.ndarray):
...
...     output = np.array([state[0]**state[1]]);
...
...     return output;
>>>
>>> model = NonlinearModel(np.ones((2, 1)), 2.5 * np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);
>>>
>>> model.get_input()
array([[2.5]])
>>>
>>> model.set_input(np.array([[5.0]]));
>>> model.get_input()
array([[5.]])

Nonlinear model -> update state

>>> import numpy as np
>>> from pynamics.models.state_space_models import NonlinearModel
>>>
>>> # Define the state function.
>>> def state_function(state: np.ndarray, control: np.ndarray, time: float):
...
...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);
...     state_derivative_2 = state[1] + control[0];
...     state_derivative = np.array([state_derivative_1, state_derivative_2]);
...
...     return state_derivative;   
>>>
>>> # Define the output function.
>>> def output_function(state: np.ndarray):
...
...     output = np.array([state[0]**state[1]]);
...
...     return output;
>>>
>>> model = NonlinearModel(np.ones((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);
>>> 
>>> model.get_state()
array([[1.],
       [1.]])
>>>
>>> model.update_state(np.zeros((2, 1)));
>>> model.get_state()
array([[0.],
       [0.]])

Nonlinear model -> eval method

>>> import numpy as np
>>> from pynamics.models.state_space_models import NonlinearModel
>>>
>>> # Define the state function.
>>> def state_function(state: np.ndarray, control: np.ndarray, time: float):
...
...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);
...     state_derivative_2 = state[1] + control[0];
...     state_derivative = np.array([state_derivative_1, state_derivative_2]);
...
...     return state_derivative;   
>>>
>>> # Define the output function.
>>> def output_function(state: np.ndarray):
...
...     output = np.array([state[0]**state[1]]);
...
...     return output;
>>>
>>> model = NonlinearModel(np.ones((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);
>>> 
>>> model.eval(t=0.0, x=model.get_state())
array([[2.08060461],
       [2.        ]])