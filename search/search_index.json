{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Pynamics documentation","text":"<p>Pynamics is a simple, lightweight Python package to simulate dynamical systems.</p> <p>It is mainly inteded as a support package for more advanced control design projects, especially projects seeking to implement advanced control systems leveraging the predictive capabilities of machine learning algorithms.</p> <p>The package provides classes to model a system (linear and nonlinear state-space models) and a simulator class that can be used to run different types of simulations. Limited control capabilities are also provided, namely a controller base class that users can build upon to design their own controllers.</p> <p>Please note that this package is NOT appropriate for extensive, extremely precise simulations.</p>"},{"location":"#main-features","title":"Main features","text":"<ul> <li> <p>Simulations: simulate dynamical systems in Python using our simulator class. Only fixed-step solvers are supported at the moment.</p> </li> <li> <p>Plot results: plot the simulation results automatically.</p> </li> <li> <p>State-space models: model your system using our generic linear and nonlinear state-space models.</p> </li> </ul>"},{"location":"#documentation-guide","title":"Documentation Guide","text":"<p>See our installation guide for detailed instructions on how to install Pynamics.</p> <p>If you require more detailed information on how to use the package (including examples), check out the API reference.</p> <p>For more information on the package's author and development process, see the About section.</p>"},{"location":"about/","title":"About","text":"<p>This package was developed by Miguel Loureiro, a Mechanical Engineer who specialises in control systems, machine learning and optimisation.</p> <p>If you're interested in any of these, feel free to contact me via email: miguel.santos.loureiro@gmail.com</p>"},{"location":"changelog/","title":"Pynamics Change Log","text":""},{"location":"changelog/#100-18092024","title":"1.0.0 - 18/09/2024","text":"<ul> <li>First major release.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-pip","title":"Using pip","text":"<p>The easiest way to install Pynamics is to install it directly from PyPi using pip:</p> <pre><code>pip install pynamics2\n</code></pre> <p>This will install the package along with its dependencies.</p> <p>If you wish to contribute to the package, install its development dependencies by typing:</p> <pre><code>pip install \"pynamics2[dev]\"\n</code></pre>"},{"location":"installation/#using-git","title":"Using git","text":"<p>Alternatively, the package can be installed via git. To do so, you must first clone the repository:</p> <pre><code>git clone https://github.com/MiguelLoureiro98/pynamics.git\n</code></pre> <p>Once the repository has been cloned, move into its directory and install the package using pip:</p> <pre><code>cd pynamics\npip install .\n</code></pre>"},{"location":"API_ref/","title":"Pynamics API reference","text":"<p>Welcome to the API reference for the Pynamics library.</p> <p>If you need more information regarding any function or class provided by Pynamics, this is the place to be.</p> <p>Each page is entirely dedicated to either a module or a class, and provides a brief descriptive summary of every function and class, parameter lists, and useful examples.</p>"},{"location":"API_ref/#modules","title":"Modules","text":"<ul> <li>Simulations: Contains the Sim class, used to run both open- and closed-loop simulations.</li> </ul>"},{"location":"API_ref/#subpackages","title":"Subpackages","text":"<ul> <li> <p>Models: Provides linear and nonlinear models of dynamical systems.</p> </li> <li> <p>Controllers: Provides (very) limited control capabilities.</p> </li> </ul>"},{"location":"API_ref/simulations/","title":"Simulations","text":""},{"location":"API_ref/simulations/#pynamics.simulations","title":"<code>pynamics.simulations</code>","text":"<p>This module provides several classes for simulating dynamical systems. Both open-loop and closed-loop simulations are supported.</p> <p>Classes:</p> Name Description <code>Sim</code> <p>Simulate a dynamical system and plot the results.</p>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim","title":"<code>Sim(system, input_signal, t0=0.0, tfinal=10.0, solver='RK4', step_size=0.001, mode='open_loop', controller=None, reference_labels=None, reference_lookahead=1, noise_power=0.0, noise_seed=0)</code>","text":"<p>               Bases: <code>_BaseSimulator</code></p> <p>Simulate a dynamical system.</p> <p>This class can be used to simulate the behaviour of a dynamical system. It supports both open-     and closed-loop simulations, which makes it appropriate for both system analysis and control design.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>BaseModel</code> <p>System to simulate. Must be described by a model supported by Pynamics.</p> required <code>input_signal</code> <code>ndarray</code> <p>Input signals. These may be reference values or other external inputs (e.g. wind speed in a wind turbine system).</p> required <code>t0</code> <code>float</code> <p>Initial time instant. Must be non-negative.</p> <code>0.0</code> <code>tfinal</code> <code>float</code> <p>Final time instant. Must be non-negative.</p> <code>0.0</code> <code>solver</code> <code>(RK4, Euler, Modified_Euler, Heun)</code> <p>Fixed-step solver.</p> <code>\"RK4\"</code> <code>step_size</code> <code>float</code> <p>Solver step size. Must be positive.</p> <code>0.001</code> <code>mode</code> <code>(open_loop, closed_loop)</code> <p>Simulation mode. The controller will not be included in the simulation unless         parameter is set to \"closed_loop\".</p> <code>\"open_loop\"</code> <code>controller</code> <code>BaseController | None</code> <p>Controller.</p> <code>None</code> <code>reference_labels</code> <code>list[str] | None</code> <p>List of labels for the reference signals.</p> <code>None</code> <code>reference_lookahead</code> <code>int</code> <p>Number of time steps ahead for which the reference values are known to the controller.</p> <code>1</code> <code>noise_power</code> <code>int | float</code> <p>White noise power. If equal to zero, no noise will be added to the simulation.</p> <code>0.0</code> <code>noise_seed</code> <code>int</code> <p>Random seed for the noise array.</p> <code>0</code> <p>Attributes:</p> Name Type Description <code>system</code> <code>BaseModel</code> <p>The system to simulate.</p> <code>options</code> <code>dict</code> <p>Simulation options (initial and final time instants).</p> <code>solver</code> <code>_FixedStepSolver</code> <p>Solver.</p> <code>time</code> <code>ndarray</code> <p>Time array.</p> <code>inputs</code> <code>ndarray</code> <p>The input signals. </p> <code>outputs</code> <code>ndarray</code> <p>The output signals.</p> <code>noise</code> <code>ndarray</code> <p>Array of white noise values.</p> <code>control_actions</code> <code>ndarray</code> <p>Array of control actions.</p> <code>controller</code> <code>BaseController</code> <p>Controller.</p> <code>ref_lookahead</code> <code>int</code> <p>Number of time steps ahead for which the reference values are known to the controller.</p> <code>ref_labels</code> <code>list[str]</code> <p>List of labels for the reference signals.</p> <p>Methods:</p> Name Description <code>summary</code> <p>Display the current simulation settings.</p> <code>run</code> <p>Run a simulation.</p> <code>reset</code> <p>Reset the output and control actions arrays, as well as the system's state and input vectors, so that a new simulation can be run.</p> <code>tracking_plot</code> <p>Evaluate the system's tracking performance by plotting the reference signal and the system's output (SISO systems only).</p> <code>system_outputs_plot</code> <p>Visualise the system's output signals.</p> <code>step_response</code> <p>Simulate the system's step response (single-input systems or single-reference controllers only).</p> <code>ramp</code> <p>Simulate the system's response to a ramp signal (single-input systems or single-reference controllers only).</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a value of the wrong type is passed as a parameter.</p> <code>ValueError</code> <p>If the value of any parameter is invalid (e.g. input signal has the wrong length,         <code>mode</code> is neither \"open_loop\" nor \"closed_loop\", etc.).</p> Warning <p>Only fixed-step solvers are support at the moment.</p> Source code in <code>pynamics/simulations.py</code> <pre><code>def __init__(self, \n             system: BaseModel, \n             input_signal: np.ndarray, \n             t0: float=0.0, \n             tfinal: float=10.0, \n             solver: str=\"RK4\", \n             step_size: float=0.001, \n             mode: str=\"open_loop\", \n             controller: BaseController | None=None, \n             reference_labels: list[str] | None=None, \n             reference_lookahead: int=1, \n             noise_power: int | float=0.0, \n             noise_seed: int=0) -&gt; None:\n    \"\"\"\n    Class constructor.\n    \"\"\"\n\n    super().__init__(system, t0, tfinal, solver, step_size);\n    self._mode_check(mode);\n    self._mode = mode;\n    self._input_checks(input_signal);\n    self._inputs = self._input_reformatting(input_signal);\n    self.outputs = np.zeros(shape=(self.system.output_dim, self.time.shape[0]));\n    self.noise = _white_noise(self.system.output_dim, self.time.shape[0], noise_power, noise_seed);\n    self._lookahead_check(reference_lookahead);\n    self._ref_lookahead = reference_lookahead;\n    self.controller = controller;\n\n    if(self._mode == \"open_loop\"):\n\n        self.controller = DummyController(self.inputs.shape[0], self.system.input_dim, step_size);\n\n    self.control_actions = np.zeros(shape=(self.controller.output_dim, self.time.shape[0]));\n    self.ref_labels = self._labels_check(reference_labels);\n\n    return;\n</code></pre>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.inputs","title":"<code>inputs: np.ndarray</code>  <code>property</code> <code>writable</code>","text":"<p>Get the input signals.</p> <p>This method can be used to access the input / reference signals using dot notation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>System input signals.</p>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.ref_lookahead","title":"<code>ref_lookahead: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the <code>ref_lookahead</code> parameter.</p> <p>This method can be used to access the value of the <code>ref_lookahead</code> parameter using dot notation.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of time steps ahead for which the reference values are known to the controller.</p>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.ramp","title":"<code>ramp(system, slope=1.0, t0=0.0, tfinal=10.0, solver='RK4', step_size=0.001, mode='open_loop', controller=None, reference_labels=None, reference_lookahead=1, noise_power=0.0, noise_seed=0)</code>  <code>classmethod</code>","text":"<p>Simulate the system's response to a ramp signal.</p> <p>This method can be used to simulate a system's response to a ramp input. Keep in mind that, for now, it should only be used         with single-input systems or controllers needing only one reference signal.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>BaseModel</code> <p>System to simulate. Must be described by a model supported by Pynamics.</p> required <code>slope</code> <code>int | float</code> <p>The ramp's slope. Unit ramp by default.</p> <code>1.0</code> <code>t0</code> <code>float</code> <p>Initial time instant. Must be non-negative.</p> <code>0.0</code> <code>tfinal</code> <code>float</code> <p>Final time instant. Must be non-negative.</p> <code>0.0</code> <code>solver</code> <code>(RK4, Euler, Modified_Euler, Heun)</code> <p>Fixed-step solver.</p> <code>\"RK4\"</code> <code>step_size</code> <code>float</code> <p>Solver step size. Must be positive.</p> <code>0.001</code> <code>mode</code> <code>(open_loop, closed_loop)</code> <p>Simulation mode. The controller will not be included in the simulation unless             parameter is set to \"closed_loop\".</p> <code>\"open_loop\"</code> <code>controller</code> <code>BaseController | None</code> <p>Controller.</p> <code>None</code> <code>reference_labels</code> <code>list[str] | None</code> <p>List of labels for the reference signals.</p> <code>None</code> <code>reference_lookahead</code> <code>int</code> <p>Number of time steps ahead for which the reference values are known to the controller.</p> <code>1</code> <code>noise_power</code> <code>int | float</code> <p>White noise power. If equal to zero, no noise will be added to the simulation.</p> <code>0.0</code> <code>noise_seed</code> <code>int</code> <p>Random seed for the noise array.</p> <code>0</code> <p>Returns:</p> Type Description <code>Sim</code> <p>A simulation class instance.</p> Warning <p>It seems this method might be somewhat inaccurate at the moment. Results might not be as reliable.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt; from pynamics.simulations import Sim\n&gt;&gt;&gt; \n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; simulation = Sim.ramp(model, slope=1);\n&gt;&gt;&gt; res = simulation.run();\n&gt;&gt;&gt; \n&gt;&gt;&gt; _ = Sim.tracking_plot(res, \"Time\", \"Ref_1\", \"y_1\");\n</code></pre> <p></p> Source code in <code>pynamics/simulations.py</code> <pre><code>@classmethod\ndef ramp(cls,\n         system: BaseModel, \n         slope: int | float=1.0, \n         t0: float=0.0, \n         tfinal: float=10.0, \n         solver: str=\"RK4\", \n         step_size: float=0.001, \n         mode: str=\"open_loop\", \n         controller: any=None, \n         reference_labels: list[str] | None=None, \n         reference_lookahead: int=1, \\\n         noise_power: int | float=0.0, \n         noise_seed: int=0):\n    \"\"\"\n    Simulate the system's response to a ramp signal.\n\n    This method can be used to simulate a system's response to a ramp input. Keep in mind that, for now, it should only be used \\\n    with single-input systems or controllers needing only one reference signal.\n\n    Parameters\n    ----------\n    system : BaseModel\n        System to simulate. Must be described by a model supported by [Pynamics](../index.md).\n\n    slope : int | float, default=1.0\n        The ramp's slope. Unit ramp by default.\n\n    t0 : float, default=0.0\n        Initial time instant. Must be non-negative.\n\n    tfinal : float, default=0.0\n        Final time instant. Must be non-negative.\n\n    solver : {\"RK4\", \"Euler\", \"Modified_Euler\", \"Heun\"}, str, default=\"RK4\"\n        Fixed-step solver.\n\n    step_size : float, default=0.001\n        Solver step size. Must be positive.\n\n    mode : {\"open_loop\", \"closed_loop\"}, str, default=\"open_loop\"\n        Simulation mode. The controller will not be included in the simulation unless \\\n        parameter is set to \"closed_loop\".\n\n    controller : BaseController | None, optional\n        Controller.\n\n    reference_labels : list[str] | None, optional\n        List of labels for the reference signals.\n\n    reference_lookahead : int, default=1\n        Number of time steps ahead for which the reference values are known to the controller.\n\n    noise_power : int | float, default=0.0\n        White noise power. If equal to zero, no noise will be added to the simulation.\n\n    noise_seed : int, default=0\n        Random seed for the noise array.\n\n    Returns\n    -------\n    Sim\n        A simulation class instance.\n\n    Warning\n    -------\n    It seems this method might be somewhat inaccurate at the moment. Results might not be as reliable.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt; from pynamics.simulations import Sim\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; simulation = Sim.ramp(model, slope=1);\n    &gt;&gt;&gt; res = simulation.run();\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; _ = Sim.tracking_plot(res, \"Time\", \"Ref_1\", \"y_1\");\n\n    ![Ramp_img](../images/Ramp_fig.png)\n    \"\"\"\n\n    reference_signal = slope * np.arange(t0, tfinal + step_size, step_size);\n\n    return cls(system, \n               reference_signal, \n               t0, \n               tfinal, \n               solver, \n               step_size, \n               mode, \n               controller, \n               reference_labels, \n               reference_lookahead, \n               noise_power, \n               noise_seed);\n</code></pre>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.reset","title":"<code>reset(initial_state, initial_control)</code>","text":"<p>Reset simulation parameters (initial conditions, output arrays, control actions).</p> <p>This method must be called every time one wishes to run another simulation. The initial conditions,         output array and control actions array are all reset. This method is useful if one wishes to run         simulations with different initial conditions or different controllers.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>ndarray</code> <p>The system's initial state. Should be an array shaped (n, 1), where n             is the number of state variables.</p> required <code>initial_control</code> <code>ndarray | float</code> <p>The inputs' initial value(s). Should be an array shaped (u, 1), where u is the number of input variables.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt; from pynamics.simulations import Sim\n&gt;&gt;&gt; \n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n&gt;&gt;&gt; res = simulation.run();\n&gt;&gt;&gt; simulation.system.x\narray([[7.98056883],\n       [1.96495125],\n       [0.98406462]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; simulation.reset(np.zeros((3, 1)), np.zeros((1, 1)));\nSim outputs and control actions were reset sucessfully.\n&gt;&gt;&gt; simulation.system.x\narray([[0.],\n       [0.],\n       [0.]])\n</code></pre> Source code in <code>pynamics/simulations.py</code> <pre><code>def reset(self, initial_state: np.ndarray, initial_control: np.ndarray | float) -&gt; None:\n    \"\"\"\n    Reset simulation parameters (initial conditions, output arrays, control actions).\n\n    This method must be called every time one wishes to run another simulation. The initial conditions, \\\n    output array and control actions array are all reset. This method is useful if one wishes to run \\\n    simulations with different initial conditions or different controllers.\n\n    Parameters\n    ----------\n    initial_state : np.ndarray\n        The system's initial state. Should be an array shaped (n, 1), where n \\\n        is the number of state variables.\n\n    initial_control: np.ndarray\n        The inputs' initial value(s). Should be an array shaped (u, 1), where\n        u is the number of input variables.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt; from pynamics.simulations import Sim\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n    &gt;&gt;&gt; res = simulation.run();\n    &gt;&gt;&gt; simulation.system.x\n    array([[7.98056883],\n           [1.96495125],\n           [0.98406462]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; simulation.reset(np.zeros((3, 1)), np.zeros((1, 1)));\n    Sim outputs and control actions were reset sucessfully.\n    &gt;&gt;&gt; simulation.system.x\n    array([[0.],\n           [0.],\n           [0.]])\n    \"\"\"\n\n    self.system.x = initial_state;\n    self.system.set_input(initial_control);\n    self.outputs = np.zeros(shape=(self.system.output_dim, self.time.shape[0]));\n    self.control_actions = np.zeros(shape=(self.controller.output_dim, self.time.shape[0]));\n    print(\"Sim outputs and control actions were reset sucessfully.\");\n\n    return;\n</code></pre>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.run","title":"<code>run()</code>","text":"<p>Run a simulation.</p> <p>This method is used to run a simulation.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Data frame containing the results.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt; from pynamics.simulations import Sim\n&gt;&gt;&gt; \n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n&gt;&gt;&gt; res = simulation.run();\n&gt;&gt;&gt; res\n         Time  Ref_1  u_1       y_1\n0       0.000    1.0  0.0  0.000000\n1       0.001    1.0  1.0  0.000996\n2       0.002    1.0  1.0  0.001984\n3       0.003    1.0  1.0  0.002964\n4       0.004    1.0  1.0  0.003936\n...       ...    ...  ...       ...\n9996    9.996    1.0  1.0  0.984014\n9997    9.997    1.0  1.0  0.984026\n9998    9.998    1.0  1.0  0.984039\n9999    9.999    1.0  1.0  0.984052\n10000  10.000    1.0  1.0  0.984065\n\n[10001 rows x 4 columns]\n</code></pre> Source code in <code>pynamics/simulations.py</code> <pre><code>def run(self) -&gt; pd.DataFrame:     \n    \"\"\"\n    Run a simulation.\n\n    This method is used to run a simulation.\n\n    Returns\n    -------\n    pd.DataFrame\n        Data frame containing the results.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt; from pynamics.simulations import Sim\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n    &gt;&gt;&gt; res = simulation.run();\n    &gt;&gt;&gt; res\n             Time  Ref_1  u_1       y_1\n    0       0.000    1.0  0.0  0.000000\n    1       0.001    1.0  1.0  0.000996\n    2       0.002    1.0  1.0  0.001984\n    3       0.003    1.0  1.0  0.002964\n    4       0.004    1.0  1.0  0.003936\n    ...       ...    ...  ...       ...\n    9996    9.996    1.0  1.0  0.984014\n    9997    9.997    1.0  1.0  0.984026\n    9998    9.998    1.0  1.0  0.984039\n    9999    9.999    1.0  1.0  0.984052\n    10000  10.000    1.0  1.0  0.984065\n    &lt;BLANKLINE&gt;\n    [10001 rows x 4 columns]\n    \"\"\"\n\n    self.control_actions[:, 0] = self.system.get_input();\n    self.outputs[:, 0] = self.system.get_output();\n\n    #for ind, (t, _, y, n, _) in enumerate(zip(self.time[:-1], self.inputs[:, :-1], self.outputs[:, :-1], self.noise[:, :-1], self.control_actions[:, :-1])):\n    for ind, t in enumerate(self.time[:-1]):\n\n        #self.outputs[:, ind+1], self.control_actions[:, ind+1] = self._step(t, ref, y + n);\n        self.outputs[:, ind+1], self.control_actions[:, ind+1] = self._step(t, self.inputs[:, ind:ind+self.ref_lookahead], self.outputs[:, ind:ind+1]); # + self.noise[:, ind:ind+1]\n        #self.outputs[:, ind+1], self.control_actions[:, ind+1] = self._step(t, self.inputs[:, ind:ind+self.ref_lookahead], y + n);\n        self.outputs[:, ind+1] += self.noise[:, ind+1];\n\n    # Create results data frame\n    names = [\"Time\"];\n    names.extend(self.ref_labels);\n    names.extend(self.system.input_labels);\n    names.extend(self.system.output_labels);\n\n    results = np.expand_dims(self.time, axis=0).T;\n    results = np.hstack((results, self.inputs.T));\n    results = np.hstack((results, self.control_actions.T));\n    results = np.hstack((results, self.outputs.T));\n\n    sim_data = pd.DataFrame(results, columns=names);\n\n    return sim_data;\n</code></pre>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.step_response","title":"<code>step_response(system, step_magnitude=1.0, t0=0.0, tfinal=10.0, solver='RK4', step_size=0.001, mode='open_loop', controller=None, reference_labels=None, reference_lookahead=1, noise_power=0.0, noise_seed=0)</code>  <code>classmethod</code>","text":"<p>Simulate the step response of a dynamical system.</p> <p>This method can be used to simulate a system's step response. Keep in mind that, for now, it should only be used         with single-input systems or controllers needing only one reference signal.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>BaseModel</code> <p>System to simulate. Must be described by a model supported by Pynamics.</p> required <code>step_magnitude</code> <code>int | float</code> <p>The step's magnitude. Unit step by default.</p> <code>1.0</code> <code>t0</code> <code>float</code> <p>Initial time instant. Must be non-negative.</p> <code>0.0</code> <code>tfinal</code> <code>float</code> <p>Final time instant. Must be non-negative.</p> <code>0.0</code> <code>solver</code> <code>(RK4, Euler, Modified_Euler, Heun)</code> <p>Fixed-step solver.</p> <code>\"RK4\"</code> <code>step_size</code> <code>float</code> <p>Solver step size. Must be positive.</p> <code>0.001</code> <code>mode</code> <code>(open_loop, closed_loop)</code> <p>Simulation mode. The controller will not be included in the simulation unless             parameter is set to \"closed_loop\".</p> <code>\"open_loop\"</code> <code>controller</code> <code>BaseController | None</code> <p>Controller.</p> <code>None</code> <code>reference_labels</code> <code>list[str] | None</code> <p>List of labels for the reference signals.</p> <code>None</code> <code>reference_lookahead</code> <code>int</code> <p>Number of time steps ahead for which the reference values are known to the controller.</p> <code>1</code> <code>noise_power</code> <code>int | float</code> <p>White noise power. If equal to zero, no noise will be added to the simulation.</p> <code>0.0</code> <code>noise_seed</code> <code>int</code> <p>Random seed for the noise array.</p> <code>0</code> <p>Returns:</p> Type Description <code>Sim</code> <p>A simulation class instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt; from pynamics.simulations import Sim\n&gt;&gt;&gt; \n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; simulation = Sim.step_response(model, step_magnitude=2);\n&gt;&gt;&gt; res = simulation.run();\n&gt;&gt;&gt; \n&gt;&gt;&gt; _ = Sim.tracking_plot(res, \"Time\", \"Ref_1\", \"y_1\");\n</code></pre> <p></p> Source code in <code>pynamics/simulations.py</code> <pre><code>@classmethod\ndef step_response(cls,\n                  system: BaseModel, \n                  step_magnitude: int | float=1.0, \n                  t0: float=0.0, \n                  tfinal: float=10.0, \n                  solver: str=\"RK4\", \n                  step_size: float=0.001, \n                  mode: str=\"open_loop\", \n                  controller: any=None, \n                  reference_labels: list[str] | None=None, \n                  reference_lookahead: int=1, \\\n                  noise_power: int | float=0.0, \n                  noise_seed: int=0):\n    \"\"\"\n    Simulate the step response of a dynamical system.\n\n    This method can be used to simulate a system's step response. Keep in mind that, for now, it should only be used \\\n    with single-input systems or controllers needing only one reference signal.\n\n    Parameters\n    ----------\n    system : BaseModel\n        System to simulate. Must be described by a model supported by [Pynamics](../index.md).\n\n    step_magnitude : int | float, default=1.0\n        The step's magnitude. Unit step by default.\n\n    t0 : float, default=0.0\n        Initial time instant. Must be non-negative.\n\n    tfinal : float, default=0.0\n        Final time instant. Must be non-negative.\n\n    solver : {\"RK4\", \"Euler\", \"Modified_Euler\", \"Heun\"}, str, default=\"RK4\"\n        Fixed-step solver.\n\n    step_size : float, default=0.001\n        Solver step size. Must be positive.\n\n    mode : {\"open_loop\", \"closed_loop\"}, str, default=\"open_loop\"\n        Simulation mode. The controller will not be included in the simulation unless \\\n        parameter is set to \"closed_loop\".\n\n    controller : BaseController | None, optional\n        Controller.\n\n    reference_labels : list[str] | None, optional\n        List of labels for the reference signals.\n\n    reference_lookahead : int, default=1\n        Number of time steps ahead for which the reference values are known to the controller.\n\n    noise_power : int | float, default=0.0\n        White noise power. If equal to zero, no noise will be added to the simulation.\n\n    noise_seed : int, default=0\n        Random seed for the noise array.\n\n    Returns\n    -------\n    Sim\n        A simulation class instance.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt; from pynamics.simulations import Sim\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; simulation = Sim.step_response(model, step_magnitude=2);\n    &gt;&gt;&gt; res = simulation.run();\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; _ = Sim.tracking_plot(res, \"Time\", \"Ref_1\", \"y_1\");\n\n    ![Step_response_img](../images/Step_response_fig.png)\n    \"\"\"\n\n    end = (tfinal - t0) / step_size + 1;\n    reference_signal = np.full(shape=(1, int(end)), fill_value=step_magnitude);\n\n    return cls(system, \n               reference_signal, \n               t0, \n               tfinal, \n               solver, \n               step_size, \n               mode, \n               controller, \n               reference_labels, \n               reference_lookahead, \n               noise_power, \n               noise_seed);\n</code></pre>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.summary","title":"<code>summary()</code>","text":"<p>Display the current simulation settings.</p> <p>This method displays the value of the most important simulation options.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt; from pynamics.simulations import Sim\n&gt;&gt;&gt; \n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n&gt;&gt;&gt; simulation.summary();\nSimulation settings\n-------------------\nInitial time step: 0.0 s\nFinal time step: 10.0 s\nSolver step size: 0.001 s\n-------------------\nInput signals format: (1, 10001)\nOutput signals format: (1, 10001)\nControl actions format: (1, 10001)\nReference lookahead: 1 time step\n-------------------\nSimulation mode: open_loop\n</code></pre> Source code in <code>pynamics/simulations.py</code> <pre><code>def summary(self) -&gt; None:\n    \"\"\"\n    Display the current simulation settings.\n\n    This method displays the value of the most important simulation options.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt; from pynamics.simulations import Sim\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n    &gt;&gt;&gt; simulation.summary();\n    Simulation settings\n    -------------------\n    Initial time step: 0.0 s\n    Final time step: 10.0 s\n    Solver step size: 0.001 s\n    -------------------\n    Input signals format: (1, 10001)\n    Output signals format: (1, 10001)\n    Control actions format: (1, 10001)\n    Reference lookahead: 1 time step\n    -------------------\n    Simulation mode: open_loop\n    \"\"\"\n\n    print(\"Simulation settings\");\n    print(\"-------------------\");\n    print(f\"Initial time step: {self._options[\"t0\"]} s\");\n    print(f\"Final time step: {self._options[\"tfinal\"]} s\");\n    print(f\"Solver step size: {self._solver.h} s\");\n    #print(f\"Solver: {self._solver}\");\n    print(\"-------------------\");\n    print(f\"Input signals format: {self._inputs.shape}\");\n    print(f\"Output signals format: {self.outputs.shape}\");\n    print(f\"Control actions format: {self.control_actions.shape}\");\n    print(f\"Reference lookahead: {self._ref_lookahead} time step\");\n    print(\"-------------------\");\n    print(f\"Simulation mode: {self._mode}\");\n    #print(f\"Controller: {self.controller}\");\n\n    return;\n</code></pre>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.system_outputs_plot","title":"<code>system_outputs_plot(sim_results, time_variable, outputs, plot_title='Simulation results', xlabel='t', ylabel='y', plot_height=10.0, plot_width=10.0)</code>  <code>staticmethod</code>","text":"<p>Visualise the system's output signals.</p> <p>This method can be use to visualise the system's output signals simultaneously.         It supports MIMO systems.</p> <p>Parameters:</p> Name Type Description Default <code>sim_results</code> <code>DataFrame</code> <p>Simulation results.</p> required <code>time_variable</code> <code>str</code> <p>Name of the time variable.</p> required <code>outputs</code> <code>list[str]</code> <p>List containing the names of the output variables.</p> required <code>plot_title</code> <code>str</code> <p>Plot title.</p> <code>\"Simulation results\"</code> <code>xlabel</code> <code>str</code> <p>X-axis label.</p> <code>\"t\"</code> <code>ylabel</code> <code>str</code> <p>Y-axis label</p> <code>\"y\"</code> <code>plot_height</code> <code>int | float</code> <p>Figure height.</p> <code>10.0</code> <code>plot_width</code> <code>int | float</code> <p>Figure width.</p> <code>10.0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt; from pynamics.simulations import Sim\n&gt;&gt;&gt; \n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n&gt;&gt;&gt; res = simulation.run();\n&gt;&gt;&gt; \n&gt;&gt;&gt; _ = Sim.system_outputs_plot(res, \"Time\", [\"y_1\"]);\n</code></pre> <p></p> Source code in <code>pynamics/simulations.py</code> <pre><code>@staticmethod\ndef system_outputs_plot(sim_results: pd.DataFrame,\n                        time_variable: str,\n                        outputs: list[str], \n                        plot_title: str=\"Simulation results\", \n                        xlabel: str=\"t\", \n                        ylabel: str=\"y\", \n                        plot_height: int | float=10.0, \n                        plot_width: int | float=10.0) -&gt; None:\n    \"\"\"\n    Visualise the system's output signals.\n\n    This method can be use to visualise the system's output signals simultaneously. \\\n    It supports MIMO systems.\n\n    Parameters\n    ----------\n    sim_results : pd.DataFrame\n        Simulation results.\n\n    time_variable : str\n        Name of the time variable.\n\n    outputs : list[str]\n        List containing the names of the output variables.\n\n    plot_title : str, default=\"Simulation results\"\n        Plot title.\n\n    xlabel : str, default=\"t\"\n        X-axis label.\n\n    ylabel : str, default=\"y\"\n        Y-axis label\n\n    plot_height : int | float, default=10.0\n        Figure height.\n\n    plot_width : int | float, default=10.0\n        Figure width.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt; from pynamics.simulations import Sim\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n    &gt;&gt;&gt; res = simulation.run();\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; _ = Sim.system_outputs_plot(res, \"Time\", [\"y_1\"]);\n\n    ![System_outputs_img](../images/Outputs_plot_fig.png)\n    \"\"\"\n\n    fig, axes = plt.subplots(len(outputs), 1, sharex=True);\n    fig.set_figheight(plot_height);\n    fig.set_figwidth(plot_width);\n    fig.suptitle(plot_title);\n    fig.supxlabel(xlabel);\n    xfactor = 1.0005;\n    yfactor = 1.05;\n\n    if (len(outputs) &gt; 1):\n\n        for it, (_, output) in enumerate(zip(axes, outputs)):\n\n            axes[it].plot(sim_results[time_variable], sim_results[output], label=output);\n            axes[it].set_ylabel(ylabel);\n            axes[it].grid(visible=True);\n            axes[it].legend();\n            axes[it].set_xlim([sim_results[time_variable].min() * xfactor, sim_results[time_variable].max() * xfactor]);\n            axes[it].set_ylim([sim_results[output].min() * yfactor, sim_results[output].max() * yfactor]);\n\n    else:\n\n        axes.plot(sim_results[time_variable], sim_results[outputs[0]], label=outputs[0]);\n        axes.set_ylabel(ylabel);\n        axes.grid(visible=True);\n        axes.legend();\n        axes.set_xlim([sim_results[time_variable].min() * xfactor, sim_results[time_variable].max() * xfactor]);\n        axes.set_ylim([sim_results[outputs[0]].min() * yfactor, sim_results[outputs[0]].max() * yfactor]); \n\n    plt.show();\n\n    return;\n</code></pre>"},{"location":"API_ref/simulations/#pynamics.simulations.Sim.tracking_plot","title":"<code>tracking_plot(sim_results, time_variable, reference, output, plot_title='Simulation results', xlabel='t', ylabel='y', plot_height=10.0, plot_width=10.0)</code>  <code>staticmethod</code>","text":"<p>Plot the reference signal and the system's output.</p> <p>Evaluate the system's tracking performance by plotting the reference signal and the system's output (SISO systems only).</p> <p>Parameters:</p> Name Type Description Default <code>sim_results</code> <code>DataFrame</code> <p>Simulation results.</p> required <code>time_variable</code> <code>str</code> <p>Name of the time variable.</p> required <code>reference</code> <code>str</code> <p>Name of the reference variable.</p> required <code>output</code> <code>str</code> <p>Name of the output variable.</p> required <code>plot_title</code> <code>str</code> <p>Plot title.</p> <code>\"Simulation results\"</code> <code>xlabel</code> <code>str</code> <p>X-axis label.</p> <code>\"t\"</code> <code>ylabel</code> <code>str</code> <p>Y-axis label.</p> <code>\"y\"</code> <code>plot_height</code> <code>int | float</code> <p>Figure height.</p> <code>10.0</code> <code>plot_width</code> <code>int | float</code> <p>Figure width.</p> <code>10.0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt; from pynamics.simulations import Sim\n&gt;&gt;&gt; \n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n&gt;&gt;&gt; res = simulation.run();\n&gt;&gt;&gt; \n&gt;&gt;&gt; _ = Sim.tracking_plot(res, \"Time\", \"Ref_1\", \"y_1\");\n</code></pre> <p></p> Source code in <code>pynamics/simulations.py</code> <pre><code>@staticmethod\ndef tracking_plot(sim_results: pd.DataFrame,\n                  time_variable: str,\n                  reference: str,\n                  output: str, \n                  plot_title: str=\"Simulation results\", \n                  xlabel: str=\"t\", \n                  ylabel: str=\"y\", \n                  plot_height: int | float=10.0, \n                  plot_width: int | float=10.0) -&gt; None:\n    \"\"\"\n    Plot the reference signal and the system's output.\n\n    Evaluate the system's tracking performance by plotting the reference signal and the system's output (SISO systems only).\n\n    Parameters\n    ----------\n    sim_results : pd.DataFrame\n        Simulation results.\n\n    time_variable : str\n        Name of the time variable.\n\n    reference : str\n        Name of the reference variable.\n\n    output : str\n        Name of the output variable.\n\n    plot_title : str, default=\"Simulation results\"\n        Plot title.\n\n    xlabel : str, default=\"t\"\n        X-axis label.\n\n    ylabel : str, default=\"y\"\n        Y-axis label.\n\n    plot_height : int | float, default=10.0\n        Figure height.\n\n    plot_width : int | float, default=10.0\n        Figure width.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt; from pynamics.simulations import Sim\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; simulation = Sim(model, input_signal=np.ones(int(10/0.001)+1));\n    &gt;&gt;&gt; res = simulation.run();\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; _ = Sim.tracking_plot(res, \"Time\", \"Ref_1\", \"y_1\");\n\n    ![Tracking_plot_img](../images/Tracking_plot_fig.png)\n    \"\"\"\n\n    _ = plt.figure(figsize=(plot_height, plot_width));\n    plt.plot(sim_results[time_variable], sim_results[reference], label=\"r\");\n    plt.plot(sim_results[time_variable], sim_results[output], label=\"y\");\n    plt.xlabel(xlabel);\n    plt.ylabel(ylabel);\n    plt.title(plot_title);\n    plt.grid(visible=True);\n    xfactor = 1.0005;\n    yfactor = 1.05;\n    minlim = np.fmin(sim_results[output].min(), sim_results[reference].min());\n    maxlim = np.fmax(sim_results[output].max(), sim_results[reference].max());\n    plt.xlim([sim_results[time_variable].min() * xfactor, sim_results[time_variable].max() * xfactor]);\n    plt.ylim([minlim * yfactor, maxlim * yfactor]);\n    plt.legend();\n    plt.show();\n\n    return;\n</code></pre>"},{"location":"API_ref/controllers/","title":"Control subpackage","text":"<p>The Pynamics control subpackage provides a basic dummy controller to help with open loop simulations. It also provides a base controller class, from which every controller compatible with Pynamics should inherit.</p>"},{"location":"API_ref/controllers/#modules","title":"Modules","text":"<ul> <li> <p>base: Contains the controller base class.</p> </li> <li> <p>dummy: Contains the Pynamics dummy controller.</p> </li> </ul>"},{"location":"API_ref/controllers/base/","title":"Controller base class","text":""},{"location":"API_ref/controllers/base/#pynamics.controllers.base","title":"<code>pynamics.controllers.base</code>","text":"<p>This module contains the controller base class. Every controller class compatible with pynamics should inherit from this class.</p> <p>Classes:</p> Name Description <code>BaseController</code> <p>Controller base class.</p>"},{"location":"API_ref/controllers/base/#pynamics.controllers.base.BaseController","title":"<code>BaseController(n_inputs, n_outputs, sampling_time)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all controllers supported by this package.</p> <p>Every controller class compatible with pynamics should inherit from this class. This is simply an abstract base class. As such, it should not be used directly. Derived classes may naturally provide methods and attributes that are not  strictly required by this base class.</p> <p>Parameters:</p> Name Type Description Default <code>n_inputs</code> <code>int</code> <p>Number of controller inputs.</p> required <code>n_outputs</code> <code>int</code> <p>Number of controller outputs.        Should be the same as the system's input dimension.</p> required <code>sampling_time</code> <code>int | float</code> <p>Controller sampling time (in seconds).</p> required <p>Attributes:</p> Name Type Description <code>input_dim</code> <code>int</code> <p>Number of controller inputs.</p> <code>output_dim</code> <code>int</code> <p>Number of controller outputs.</p> <code>Ts</code> <code>int | float</code> <p>Controller sampling time (in seconds).</p> <p>Methods:</p> Name Description <code>info</code> <p>Display useful information regarding the controller.</p> <code>control</code> <p>Compute control actions for the next time instant.</p> Warning <p>This is an abstract base class. It should not be used directly.</p> Source code in <code>pynamics/controllers/base.py</code> <pre><code>def __init__(self, n_inputs: int, n_outputs: int, sampling_time: int | float) -&gt; None:\n\n    \"\"\"\n    Class constructor.\n    \"\"\"\n\n    super().__init__();\n    self._input_dim = n_inputs;\n    self._output_dim = n_outputs;\n    self._sampling_time = sampling_time;\n\n    return;\n</code></pre>"},{"location":"API_ref/controllers/base/#pynamics.controllers.base.BaseController.Ts","title":"<code>Ts: int | float</code>  <code>property</code> <code>writable</code>","text":"<p>Get the controller's sampling time.</p> <p>This method can be used to access the controller's sampling time using dot notation.</p> <p>Returns:</p> Type Description <code>int | float</code> <p>Controller sampling time (seconds).</p>"},{"location":"API_ref/controllers/base/#pynamics.controllers.base.BaseController.input_dim","title":"<code>input_dim: int</code>  <code>property</code>","text":"<p>Get the controller's input dimension.</p> <p>This method can be used to access the number of controller input variables using dot notation.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of controller inputs.</p>"},{"location":"API_ref/controllers/base/#pynamics.controllers.base.BaseController.output_dim","title":"<code>output_dim: int</code>  <code>property</code>","text":"<p>Get the controller's output dimension.</p> <p>This method can be used to access the number of controller output variables using dot notation.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of controller outputs.</p>"},{"location":"API_ref/controllers/base/#pynamics.controllers.base.BaseController.control","title":"<code>control(ref, y)</code>  <code>abstractmethod</code>","text":"<p>Computes the control actions for the next time instant.</p> <p>Abstract method. Implementation details are specific to each controller and should therefore vary considerably.</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>ndarray</code> <p>Array of reference values. For regulation problems, this should be an array of zeros.</p> required <code>y</code> <code>ndarray</code> <p>System state vector. Note that this refers only to the latest time instant.             If a controller requires information from earlier time instants, it should store             it internally.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of control actions.</p> Source code in <code>pynamics/controllers/base.py</code> <pre><code>@abstractmethod\ndef control(self, ref: np.ndarray, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the control actions for the next time instant.\n\n    Abstract method. Implementation details are specific to each controller and should therefore vary considerably.\n\n    Parameters\n    ----------\n    ref : np.ndarray\n        Array of reference values. For regulation problems, this should be an array of zeros.\n\n    y : np.ndarray\n        System state vector. Note that this refers only to the latest time instant. \\\n        If a controller requires information from earlier time instants, it should store \\\n        it internally.\n\n    Returns\n    -------\n    np.ndarray\n        Array of control actions.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_ref/controllers/base/#pynamics.controllers.base.BaseController.info","title":"<code>info()</code>  <code>abstractmethod</code>","text":"<p>Provides useful information regarding the controller.</p> <p>Abstract method. Implementation details are specific to each controller and should therefore vary considerably.</p> Source code in <code>pynamics/controllers/base.py</code> <pre><code>@abstractmethod\ndef info(self) -&gt; None:\n    \"\"\"\n    Provides useful information regarding the controller.\n\n    Abstract method. Implementation details are specific to each controller and should therefore vary considerably.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_ref/controllers/dummy/","title":"Pynamics Dummy Controller","text":""},{"location":"API_ref/controllers/dummy/#pynamics.controllers.dummy","title":"<code>pynamics.controllers.dummy</code>","text":""},{"location":"API_ref/controllers/dummy/#pynamics.controllers.dummy.DummyController","title":"<code>DummyController(n_inputs, n_outputs, sampling_time)</code>","text":"<p>               Bases: <code>BaseController</code></p> <p>This class defines the dummy controller used by the pynamics package to run open-loop simulations. The controller performs no computations.</p> <p>Attributes:</p> Name Type Description <code>input_dim</code> <code>int</code> <p>The number of controller inputs.</p> <code>output_dim</code> <code>int</code> <p>The number of control actions (one for a single-output controller / single-input system).</p> <code>Ts</code> <code>int | float</code> <p>Controller sampling time.</p> <p>Methods:</p> Name Description <code>info</code> <p>Display a warning.</p> <code>control</code> <p>Compute the control actions for the next time instant. In practice, it simply outputs the value of <code>ref</code>.</p> Source code in <code>pynamics/controllers/dummy.py</code> <pre><code>def __init__(self, n_inputs: int, n_outputs: int, sampling_time: int | float) -&gt; None:\n    \"\"\"\n    Class constructor.\n    \"\"\"\n\n    super().__init__(n_inputs, n_outputs, sampling_time);\n\n    return;\n</code></pre>"},{"location":"API_ref/controllers/dummy/#pynamics.controllers.dummy.DummyController.control","title":"<code>control(ref, y)</code>","text":"<p>Computes the control actions for the next time instant.</p> <p>This method outputs the control actions for the next time instant, which in this case are simply the reference values.</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>ndarray</code> <p>Array of reference values. For regulation problems, this should be an array of zeros.</p> required <code>y</code> <code>ndarray</code> <p>System state vector. Used for compatibility reasons. Unused by this 'controller'.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of control actions. In this case, the reference values themselves.</p> Source code in <code>pynamics/controllers/dummy.py</code> <pre><code>def control(self, ref: np.ndarray, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Computes the control actions for the next time instant.\n\n    This method outputs the control actions for the next time instant, which in this case are simply the reference values.\n\n    Parameters\n    ----------\n    ref : np.ndarray\n        Array of reference values. For regulation problems, this should be an array of zeros.\n\n    y : np.ndarray\n        System state vector. Used for compatibility reasons. Unused by this 'controller'.\n\n    Returns\n    -------\n    np.ndarray\n        Array of control actions. In this case, the reference values themselves.\n    \"\"\"\n\n    return ref;\n</code></pre>"},{"location":"API_ref/controllers/dummy/#pynamics.controllers.dummy.DummyController.info","title":"<code>info()</code>","text":"<p>Provides useful information regarding the controller.</p> <p>This method issues a warning to the user that this 'controller' should not be used         as a benchmark of any kind. It is simply used for open-loop simulations.</p> Source code in <code>pynamics/controllers/dummy.py</code> <pre><code>def info(self) -&gt; None:\n    \"\"\"\n    Provides useful information regarding the controller.\n\n    This method issues a warning to the user that this 'controller' should not be used \\\n    as a benchmark of any kind. It is simply used for open-loop simulations.\n    \"\"\"\n\n    print(\"pynamics Dummy Controller\");\n    print(\"-------------------------\");\n    print(\"pynamics makes use of this class in open-loop simulations. \\\n          It is not really a controller, as its output will simply be \\\n          the reference signal. No computations are performed.\");\n    print(\"WARNING: for the reasons stated above, this controller should NOT be used \\\n          as a baseline. Its use is equivalent to an open-loop simulation.\");\n\n    return;\n</code></pre>"},{"location":"API_ref/models/","title":"Models subpackage","text":"<p>The Pynamics models subpackage implements generic state-space models that can be used to describe the systems one wishes to simulate. Additionally, it provides helpful model conversion functions.</p>"},{"location":"API_ref/models/#modules","title":"Modules","text":"<ul> <li> <p>Base: Contains the model base class.</p> </li> <li> <p>State-space models: Implements linear and nonlinear state-space models.</p> </li> <li> <p>Model conversions: Provides functions to convert pynamics models into control models and vice-versa.</p> </li> </ul>"},{"location":"API_ref/models/base/","title":"Model base class","text":""},{"location":"API_ref/models/base/#pynamics.models.base","title":"<code>pynamics.models.base</code>","text":"<p>This module contains the model base class, which forms the template for every plant model supported by this package.</p> <p>Classes:</p> Name Description <code>BaseModel</code> <p>Model base class.</p>"},{"location":"API_ref/models/base/#pynamics.models.base.BaseModel","title":"<code>BaseModel(initial_state, input_dim, output_dim, input_labels=None, output_labels=None)</code>","text":"<p>               Bases: <code>ABC</code></p> <p>This is the parent class for every plant model supported by pynamics.  While custom models are supported, they must all inherit from this class.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>ndarray</code> <p>The system's initial state. Should be an array shaped (n, 1), where n is the number of         state variables.</p> required <code>input_dim</code> <code>int</code> <p>Number of system inputs.</p> required <code>output_dim</code> <code>int</code> <p>Number of system outputs.</p> required <code>input_labels</code> <code>list[str] | None</code> <p>List of input labels. If <code>None</code> is passed, the inputs will be given generic names.</p> <code>None</code> <code>output_labels</code> <code>list[str] | None</code> <p>List of output labels. If <code>None</code> is passed, the outputs will be given generic names.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>The system's state vector.</p> <code>input_dim</code> <code>int</code> <p>Number of system inputs.</p> <code>output_dim</code> <code>int</code> <p>Number of system outputs.</p> <code>state_dim</code> <code>int</code> <p>Number of states in the state vector.</p> <code>input_labels</code> <code>list[str]</code> <p>List of input labels.</p> <code>output_labels</code> <code>list[str]</code> <p>List of output labels.</p> <p>Methods:</p> Name Description <code>get_state</code> <p>Get the current state vector.</p> <code>get_output</code> <p>Compute the system's output from the current state.</p> <code>get_input</code> <p>Get the current inputs.</p> <code>set_input</code> <p>Pass new inputs to the system.</p> <code>update_state</code> <p>Assign new values to the system's state vector.</p> <code>eval</code> <p>Compute the system's state derivative.</p> Warning <p>This is an abstract base class. It should not be used directly.</p> Source code in <code>pynamics/models/base.py</code> <pre><code>def __init__(self, \n             initial_state: np.ndarray, \n             input_dim: int, \n             output_dim: int,\n             input_labels: list[str] | None=None, \n             output_labels: list[str] | None=None) -&gt; None:\n\n    \"\"\"\n    Class constructor.\n    \"\"\"\n\n    super().__init__();\n    self.x = initial_state;\n    self._dim_checks(input_dim, output_dim);\n    self.input_dim = input_dim;\n    self.output_dim = output_dim;\n    self.state_dim = self.x.shape[0];\n    self.input_labels = self._labels_check(input_labels, self.input_dim, \"u\");\n    self.output_labels = self._labels_check(output_labels, self.output_dim, \"y\");\n\n    return;\n</code></pre>"},{"location":"API_ref/models/base/#pynamics.models.base.BaseModel.eval","title":"<code>eval()</code>  <code>abstractmethod</code>","text":"<p>Compute the system's state derivative.</p> <p>Abstract method. Implementation details may vary with the model.</p> Source code in <code>pynamics/models/base.py</code> <pre><code>@abstractmethod\ndef eval(self) -&gt; np.ndarray:\n    \"\"\"\n    Compute the system's state derivative.\n\n    Abstract method. Implementation details may vary with the model.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_ref/models/base/#pynamics.models.base.BaseModel.get_input","title":"<code>get_input()</code>  <code>abstractmethod</code>","text":"<p>Access the system's input.</p> <p>Abstract method. Implementation details may vary with the model.</p> Source code in <code>pynamics/models/base.py</code> <pre><code>@abstractmethod\ndef get_input(self) -&gt; np.ndarray:\n    \"\"\"\n    Access the system's input.\n\n    Abstract method. Implementation details may vary with the model.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_ref/models/base/#pynamics.models.base.BaseModel.get_output","title":"<code>get_output()</code>  <code>abstractmethod</code>","text":"<p>Compute the system's output from the current state vector.</p> <p>Abstract method. Implementation details may vary with the model.</p> Source code in <code>pynamics/models/base.py</code> <pre><code>@abstractmethod\ndef get_output(self) -&gt; np.ndarray:\n    \"\"\"\n    Compute the system's output from the current state vector.\n\n    Abstract method. Implementation details may vary with the model.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_ref/models/base/#pynamics.models.base.BaseModel.get_state","title":"<code>get_state()</code>  <code>abstractmethod</code>","text":"<p>Access the system's state.</p> <p>Abstract method. Implementation details may vary with the model.</p> Source code in <code>pynamics/models/base.py</code> <pre><code>@abstractmethod\ndef get_state(self) -&gt; np.ndarray:\n    \"\"\"\n    Access the system's state.\n\n    Abstract method. Implementation details may vary with the model.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_ref/models/base/#pynamics.models.base.BaseModel.set_input","title":"<code>set_input(u)</code>  <code>abstractmethod</code>","text":"<p>Pass a new set of inputs (references, control actions, etc.) to the system.</p> <p>Abstract method. Implementation details may vary with the model.</p> Source code in <code>pynamics/models/base.py</code> <pre><code>@abstractmethod\ndef set_input(self, u: np.ndarray | float) -&gt; None:\n    \"\"\"\n    Pass a new set of inputs (references, control actions, etc.) to the system.\n\n    Abstract method. Implementation details may vary with the model.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_ref/models/base/#pynamics.models.base.BaseModel.update_state","title":"<code>update_state()</code>  <code>abstractmethod</code>","text":"<p>Assign new values to the system's state vector.</p> <p>Abstract method. Implementation details may vary with the model.</p> Source code in <code>pynamics/models/base.py</code> <pre><code>@abstractmethod\ndef update_state(self) -&gt; None:\n    \"\"\"\n    Assign new values to the system's state vector.\n\n    Abstract method. Implementation details may vary with the model.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_ref/models/conversions/","title":"Model conversions","text":""},{"location":"API_ref/models/conversions/#pynamics.models.model_conversion","title":"<code>pynamics.models.model_conversion</code>","text":"<p>This module contains helper functions that make Pynamics compatible with the Python Control Systems Library.</p> <p>Functions:</p> Name Description <code>pynamics_to_control</code> <p>Convert a pynamics linear state-space model to a control state-space model.</p> <code>control_to_pynamics</code> <p>Convert a control state-space model to a pynamics state-space model.</p>"},{"location":"API_ref/models/conversions/#pynamics.models.model_conversion.control_to_pynamics","title":"<code>control_to_pynamics(control_model, initial_state, initial_control, input_labels=None, output_labels=None)</code>","text":"<p>Convert a control linear state-space model to a pynamics linear model.</p> <p>This method can be used to convert a control model to a pynamics model, thus making the two libraries compatible.</p> <p>Parameters:</p> Name Type Description Default <code>control_model</code> <code>ss</code> <p>A Python Control Systems library linear state-space model.</p> required <code>initial_state</code> <code>ndarray</code> <p>The system's initial state. Should be an array shaped (n, 1), where n is the number of variables.</p> required <code>initial_control</code> <code>ndarray</code> <p>The inputs' initial value(s). Should be an array shaped (u, 1), where u is the number of input variables.</p> required <code>input_labels</code> <code>list[str] | None</code> <p>Names of the input variables. Should be a list of length n.</p> <code>None</code> <code>output_labels</code> <code>list[str] | None</code> <p>Names of the output variables. Should be a list of length u.</p> <code>None</code> <p>Returns:</p> Type Description <code>LinearModel</code> <p>A pynamics linear model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import control as ct\n&gt;&gt;&gt; from pynamics.models.model_conversion import control_to_pynamics\n&gt;&gt;&gt;\n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; ct_model = ct.ss(A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; py_model = control_to_pynamics(ct_model, initial_state=np.zeros((3, 1)), initial_control=np.zeros((1, 1)));\n&gt;&gt;&gt; isinstance(py_model, pynamics.models.state_space_models.LinearModel)\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; py_model.A\narray([[ 0.,  0., -1.],\n       [ 1.,  0., -3.],\n       [ 0.,  1., -3.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; py_model.B\narray([[ 1.],\n       [-5.],\n       [ 1.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; py_model.C\narray([[0., 0., 1.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; py_model.D\narray([[0.]])\n</code></pre> Source code in <code>pynamics/models/model_conversion.py</code> <pre><code>def control_to_pynamics(control_model: ct.ss, \n                        initial_state: np.ndarray, \n                        initial_control: np.ndarray,\n                        input_labels: list[str] | None=None, \n                        output_labels: list[str] | None=None) -&gt; LinearModel:\n    \"\"\"\n    Convert a control linear state-space model to a pynamics linear model.\n\n    This method can be used to convert a control model to a pynamics model, thus making the two libraries compatible.\n\n    Parameters\n    ----------\n    control_model : ct.ss\n        A Python Control Systems library linear state-space model.\n\n    initial_state : np.ndarray\n        The system's initial state. Should be an array shaped (n, 1), where\n        n is the number of variables.\n\n    initial_control : np.ndarray\n        The inputs' initial value(s). Should be an array shaped (u, 1), where\n        u is the number of input variables.\n\n    input_labels : list[str] | None, optional\n        Names of the input variables. Should be a list of length n.\n\n    output_labels : list[str] | None, optional\n        Names of the output variables. Should be a list of length u.\n\n    Returns\n    -------\n    LinearModel\n        A pynamics linear model.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import control as ct\n    &gt;&gt;&gt; from pynamics.models.model_conversion import control_to_pynamics\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; ct_model = ct.ss(A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; py_model = control_to_pynamics(ct_model, initial_state=np.zeros((3, 1)), initial_control=np.zeros((1, 1)));\n    &gt;&gt;&gt; isinstance(py_model, pynamics.models.state_space_models.LinearModel)\n    True\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; py_model.A\n    array([[ 0.,  0., -1.],\n           [ 1.,  0., -3.],\n           [ 0.,  1., -3.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; py_model.B\n    array([[ 1.],\n           [-5.],\n           [ 1.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; py_model.C\n    array([[0., 0., 1.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; py_model.D\n    array([[0.]])\n    \"\"\"\n\n    return LinearModel(initial_state, \n                       initial_control, \n                       control_model.A, \n                       control_model.B, \n                       control_model.C, \n                       control_model.D, \n                       input_labels, \n                       output_labels);\n</code></pre>"},{"location":"API_ref/models/conversions/#pynamics.models.model_conversion.pynamics_to_control","title":"<code>pynamics_to_control(pynamics_model)</code>","text":"<p>Convert a pynamics linear model to a control linear state-space model.</p> <p>This method can be used to convert a pynamics model to a control model, thus making the two libraries compatible.</p> <p>Parameters:</p> Name Type Description Default <code>pynamics_model</code> <code>LinearModel</code> <p>A pynamics linear state-space model.</p> required <p>Returns:</p> Type Description <code>ss</code> <p>A state-space model compatible with the Python Control Systems library.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import control as ct\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt; from pynamics.models.model_conversion import pynamics_to_control\n&gt;&gt;&gt;\n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; py_model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; ct_model = pynamics_to_control(py_model);\n&gt;&gt;&gt; isinstance(ct_model, ct.statesp.StateSpace)\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; ct_model.A\narray([[ 0.,  0., -1.],\n       [ 1.,  0., -3.],\n       [ 0.,  1., -3.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; ct_model.B\narray([[ 1.],\n       [-5.],\n       [ 1.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; ct_model.C\narray([[0., 0., 1.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; ct_model.D\narray([[0.]])\n</code></pre> Source code in <code>pynamics/models/model_conversion.py</code> <pre><code>def pynamics_to_control(pynamics_model: LinearModel) -&gt; ct.ss:\n    \"\"\"\n    Convert a pynamics linear model to a control linear state-space model.\n\n    This method can be used to convert a pynamics model to a control model, thus making the two libraries compatible.\n\n    Parameters\n    ----------\n    pynamics_model : LinearModel\n        A pynamics linear state-space model.\n\n    Returns\n    -------\n    ct.ss\n        A state-space model compatible with the Python Control Systems library.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import control as ct\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt; from pynamics.models.model_conversion import pynamics_to_control\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; py_model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; ct_model = pynamics_to_control(py_model);\n    &gt;&gt;&gt; isinstance(ct_model, ct.statesp.StateSpace)\n    True\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; ct_model.A\n    array([[ 0.,  0., -1.],\n           [ 1.,  0., -3.],\n           [ 0.,  1., -3.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; ct_model.B\n    array([[ 1.],\n           [-5.],\n           [ 1.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; ct_model.C\n    array([[0., 0., 1.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; ct_model.D\n    array([[0.]])\n    \"\"\"\n\n    return ct.ss(pynamics_model.A, pynamics_model.B, pynamics_model.C, pynamics_model.D);\n</code></pre>"},{"location":"API_ref/models/state_space/","title":"State-space models","text":""},{"location":"API_ref/models/state_space/#pynamics.models.state_space_models","title":"<code>pynamics.models.state_space_models</code>","text":"<p>This module contains all state-space models supported by this package.</p> <p>Classes:</p> Name Description <code>LinearModel</code> <p>Implements a linear time-invariant state-space model.</p> <code>NonlinearModel</code> <p>Implements a generic nonlinear model. Supports time-varying and parameter-varying models (including linear ones).</p>"},{"location":"API_ref/models/state_space/linear/","title":"Linear models","text":""},{"location":"API_ref/models/state_space/linear/#pynamics.models.state_space_models.LinearModel","title":"<code>pynamics.models.state_space_models.LinearModel(initial_state, initial_control, A, B, C, D, input_labels=None, output_labels=None)</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Linear time-invariant state-space model.</p> <p>This class implements a generic linear time-invariant state-space model.     It is intended to model continuous-time systems. Hybrid and discrete-time     systems are not supported by pynamics.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>ndarray</code> <p>The system's initial state. Should be an array shaped (n, 1), where         n is the number of state variables.</p> required <code>initial_control</code> <code>ndarray</code> <p>The inputs' initial value(s). Should be an array shaped (u, 1), where         u is the number of input variables.</p> required <code>A</code> <code>ndarray</code> <p>Dynamics matrix. It maps the state vector to the state derivatives.</p> required <code>B</code> <code>ndarray</code> <p>Input matrix. It maps the input vector to the state derivatives.</p> required <code>C</code> <code>ndarray</code> <p>Output matrix. It maps the state vector to the output vector.</p> required <code>D</code> <code>ndarray</code> <p>Direct or feedforward matrix. It maps the input vector to the output vector.</p> required <code>input_labels</code> <code>list[str] | None</code> <p>List of input labels. If <code>None</code> is passed, the inputs will be given generic names.</p> <code>None</code> <code>output_labels</code> <code>list[str] | None</code> <p>List of output labels. If <code>None</code> is passed, the outputs will be given generic names.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>The system's state vector. Should be an array shaped (n, 1), where n is the         number of state variables.</p> <code>u</code> <code>ndarray</code> <p>Input vector. Should be an array shaped (u, 1), where         u is the number of input variables.</p> <code>A</code> <code>ndarray</code> <p>Dynamics matrix. It maps the state vector to the state derivatives.</p> <code>B</code> <code>ndarray</code> <p>Input matrix. It maps the input vector to the state derivatives.</p> <code>C</code> <code>ndarray</code> <p>Output matrix. It maps the state vector to the output vector.</p> <code>D</code> <code>ndarray</code> <p>Direct or feedforward matrix. It maps the input vector to the output vector.</p> <code>input_labels</code> <code>list[str]</code> <p>List of input labels.</p> <code>output_labels</code> <code>list[str]</code> <p>List of output labels.</p> <p>Methods:</p> Name Description <code>get_state</code> <p>Get the current state vector.</p> <code>get_output</code> <p>Compute the system's output from the current state.</p> <code>get_input</code> <p>Get the current inputs.</p> <code>set_input</code> <p>Pass new inputs to the system.</p> <code>update_state</code> <p>Assign new values to the system's state vector.</p> <code>eval</code> <p>Compute the system's state derivative.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the matrices is not an np.array.</p> <code>ValueError</code> <p>If any of the matrices has incorrect dimensions.</p> See also <p>NonlinearModel:     Implements a nonlinear state-space model. Supports linear time-varying systems and linear parameter-varying systems,         as well as generic nonlinear systems.</p> Notes <p>A linear state-space model describes the relation between the inputs and outputs of a system as a set     of linear, first-order differential equations. These equations may be written in matrix form:</p> \\[ \\dot{x}(t) = A \\cdot x(t) + B \\cdot u(t) \\] \\[ y(t) = C \\cdot x(t) + D \\cdot u(t) \\] <p>where \\(x\\) is called the state vector, \\(u\\) is the input vector and \\(y\\) is the output vector.  The first equation is called the state equation, and the second one is the output equation.  The former relates the system's current state and the inputs to the change in state, while the latter     relates those same quantities to the system's outputs.</p> <p>If the system is time-invariant (as assumed by this class), then the A, B, C and D matrices are constant.</p> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def __init__(self, initial_state: np.ndarray, \n             initial_control: np.ndarray | float, \n             A: np.ndarray, \n             B: np.ndarray, \n             C: np.ndarray, \n             D: np.ndarray,\n             input_labels: list[str] | None=None, \n             output_labels: list[str] | None=None) -&gt; None:\n\n    \"\"\"\n    Class constructor.\n    \"\"\"\n\n    self._matrix_type_checks(A, B, C, D);\n    C, D = self._matrix_reformatting(C, D);\n    super().__init__(initial_state, B.shape[1], C.shape[0], input_labels, output_labels);\n    self.u = self._control_type_checks(initial_control);\n    self._matrix_dim_checks(A, B, C, D);\n    self.A = A;\n    self.B = B;\n    self.C = C;\n    self.D = D;\n\n    return;\n</code></pre>"},{"location":"API_ref/models/state_space/linear/#pynamics.models.state_space_models.LinearModel.eval","title":"<code>eval(t, x)</code>","text":"<p>Compute the system's state derivative.</p> <p>This method computes the system's state derivative via the state         equation: \\(\\dot{x} = A \\cdot x + B \\cdot u\\), where \\(x\\) is the state vector         and \\(u\\) is the input vector.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time instant. Used for compatibility reasons. Unused by this method.</p> required <code>x</code> <code>ndarray</code> <p>The current state vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The system's state derivative.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.ones((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.eval(0.0, x=model.get_state())\narray([[-1.],\n       [-2.],\n       [-2.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def eval(self, t: float, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the system's state derivative.\n\n    This method computes the system's state derivative via the state \\\n    equation: $\\dot{x} = A \\cdot x + B \\cdot u$, where $x$ is the state vector \\\n    and $u$ is the input vector.\n\n    Parameters\n    ----------\n    t : float\n        Time instant. Used for compatibility reasons. Unused by this method.\n\n    x : np.ndarray\n        The current state vector.\n\n    Returns\n    -------\n    np.ndarray\n        The system's state derivative.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.ones((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.eval(0.0, x=model.get_state())\n    array([[-1.],\n           [-2.],\n           [-2.]])\n    \"\"\"\n\n    return np.matmul(self.A, x) + np.matmul(self.B, self.u);\n</code></pre>"},{"location":"API_ref/models/state_space/linear/#pynamics.models.state_space_models.LinearModel.get_input","title":"<code>get_input()</code>","text":"<p>Access the system's input.</p> <p>This method can be use to access the current input vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current input vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.ones((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.get_input()\narray([[1.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def get_input(self) -&gt; np.ndarray:\n    \"\"\"\n    Access the system's input.\n\n    This method can be use to access the current input vector.\n\n    Returns\n    -------\n    np.ndarray\n        Current input vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.ones((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.get_input()\n    array([[1.]])\n    \"\"\"\n\n    return self.u;\n</code></pre>"},{"location":"API_ref/models/state_space/linear/#pynamics.models.state_space_models.LinearModel.get_output","title":"<code>get_output()</code>","text":"<p>Compute the system's output from the current state vector.</p> <p>This method can be used to compute the output of a linear state-space         model from its current state vector. This is done by computing         \\(y = C \\cdot x + D \\cdot u\\), where \\(y\\) is the output vector, \\(x\\) is the state vector,         and \\(u\\) is the input vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Output vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.ones((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.get_output()\narray([[1.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def get_output(self) -&gt; np.ndarray:\n    \"\"\"\n    Compute the system's output from the current state vector.\n\n    This method can be used to compute the output of a linear state-space \\\n    model from its current state vector. This is done by computing \\\n    $y = C \\cdot x + D \\cdot u$, where $y$ is the output vector, $x$ is the state vector, \\\n    and $u$ is the input vector.\n\n    Returns\n    -------\n    np.ndarray\n        Output vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.ones((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.get_output()\n    array([[1.]])\n    \"\"\"\n\n    return np.matmul(self.C, self.x) + np.matmul(self.D, self.u);\n</code></pre>"},{"location":"API_ref/models/state_space/linear/#pynamics.models.state_space_models.LinearModel.get_state","title":"<code>get_state()</code>","text":"<p>Access the system's state.</p> <p>This method allows one to access the current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current state vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.get_state()\narray([[0.],\n       [0.],\n       [0.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def get_state(self) -&gt; np.ndarray:  \n    \"\"\"\n    Access the system's state.\n\n    This method allows one to access the current state vector.\n\n    Returns\n    -------\n    np.ndarray\n        Current state vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.get_state()\n    array([[0.],\n           [0.],\n           [0.]]) \n    \"\"\"\n\n    return self.x;\n</code></pre>"},{"location":"API_ref/models/state_space/linear/#pynamics.models.state_space_models.LinearModel.set_input","title":"<code>set_input(u)</code>","text":"<p>Pass a new set of inputs (references, control actions, etc.) to the system.</p> <p>This method can be used to update the system's input vector directly.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray | float</code> <p>The new set of inputs (i.e. input vector).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.ones((1, 1)), A, B, C, D);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.get_input()\narray([[1.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.set_input(np.array([[5]]));\n&gt;&gt;&gt; model.get_input()\narray([[5.]])\n</code></pre> <p>For single-input systems, floats and integers also constitute valid inputs:</p> <pre><code>&gt;&gt;&gt; model.set_input(2.5);\n&gt;&gt;&gt; model.get_input()\narray([[2.5]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def set_input(self, u: np.ndarray | float) -&gt; None:\n    \"\"\"\n    Pass a new set of inputs (references, control actions, etc.) to the system.\n\n    This method can be used to update the system's input vector directly.\n\n    Parameters\n    ----------\n    u : np.ndarray | float\n        The new set of inputs (i.e. input vector).\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.ones((1, 1)), A, B, C, D);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.get_input()\n    array([[1.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.set_input(np.array([[5]]));\n    &gt;&gt;&gt; model.get_input()\n    array([[5.]])\n\n    For single-input systems, floats and integers also constitute valid inputs:\n\n    &gt;&gt;&gt; model.set_input(2.5);\n    &gt;&gt;&gt; model.get_input()\n    array([[2.5]])\n    \"\"\"\n\n    self.u = self._control_type_checks(u);\n\n    return;\n</code></pre>"},{"location":"API_ref/models/state_space/linear/#pynamics.models.state_space_models.LinearModel.update_state","title":"<code>update_state(state)</code>","text":"<p>Assign new values to the system's state vector.</p> <p>This method can be used to update the system's state vector directly.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ndarray</code> <p>New state vector.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n&gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n&gt;&gt;&gt; C = np.array([0, 0, 1]);\n&gt;&gt;&gt; D = np.array([0]);\n&gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n&gt;&gt;&gt; \n&gt;&gt;&gt; model.get_state()\narray([[0.],\n       [0.],\n       [0.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.update_state(np.ones((3, 1)));\n&gt;&gt;&gt; model.get_state()\narray([[1.],\n       [1.],\n       [1.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def update_state(self, state: np.ndarray) -&gt; None:\n    \"\"\"\n    Assign new values to the system's state vector.\n\n    This method can be used to update the system's state vector directly.\n\n    Parameters\n    ----------\n    state : np.ndarray\n        New state vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import LinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; A = np.array([[0, 0, -1], [1, 0, -3], [0, 1, -3]]);\n    &gt;&gt;&gt; B = np.array([1, -5, 1]).reshape(-1, 1);\n    &gt;&gt;&gt; C = np.array([0, 0, 1]);\n    &gt;&gt;&gt; D = np.array([0]);\n    &gt;&gt;&gt; model = LinearModel(np.zeros((3, 1)), np.zeros((1, 1)), A, B, C, D);\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; model.get_state()\n    array([[0.],\n           [0.],\n           [0.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.update_state(np.ones((3, 1)));\n    &gt;&gt;&gt; model.get_state()\n    array([[1.],\n           [1.],\n           [1.]])\n    \"\"\"\n\n    self.x = state;\n\n    return;\n</code></pre>"},{"location":"API_ref/models/state_space/nonlinear/","title":"Nonlinear models","text":""},{"location":"API_ref/models/state_space/nonlinear/#pynamics.models.state_space_models.NonlinearModel","title":"<code>pynamics.models.state_space_models.NonlinearModel(initial_state, initial_control, state_update_fcn, state_output_fcn, input_dim, output_dim, input_labels=None, output_labels=None)</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic nonlinear state-space model.</p> <p>This class implements a generic continuous nonlinear state-space model. Since both the state equations and the output equations are user-defined, time-varying systems are supported. In order to implement such a system, the state and/or the output equations should explicitly dependent on time.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>ndarray</code> <p>The system's state vector. Should be an array shaped (n, 1), where n is the         number of state variables.</p> required <code>initial_control</code> <code>ndarray</code> <p>Input vector. Should be an array shaped (u, 1), where         u is the number of input variables.</p> required <code>state_update_fcn</code> <code>callable</code> <p>State update function. This function should implement the system's state equations,         i.e. it should compute its state derivatives given the inputs and the current state vector.</p> required <code>state_output_fcn</code> <code>callable</code> <p>Output function. This function should implement the system's output equations,         i.e. it should compute its output vector given the inputs and the current state vector.</p> required <code>input_dim</code> <code>int</code> <p>Number of system inputs.</p> required <code>output_dim</code> <code>int</code> <p>Number of system outputs.</p> required <code>input_labels</code> <code>list[str]</code> <p>List of input labels.</p> <code>None</code> <code>output_labels</code> <code>list[str]</code> <p>List of output labels.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>The system's state. Should be an array of shape (n, 1), where n is the number of         variables.</p> <code>state_equations</code> <code>callable</code> <p>The state equations. These describe the evolution of the system's state depending         on its current state and its inputs.</p> <code>output_equations</code> <code>callable</code> <p>The output equations. These relate the system's state to its output.</p> <code>u</code> <code>ndarray</code> <p>The current control action, or set of control actions, defined as an (n, 1)-shaped         array, where n is the number of controlled inputs. </p> <p>Methods:</p> Name Description <code>get_state</code> <p>Get the current state vector.</p> <code>get_output</code> <p>Compute the system's output from the current state.</p> <code>get_input</code> <p>Get the current inputs.</p> <code>set_input</code> <p>Pass new inputs to the system.</p> <code>update_state</code> <p>Assign new values to the system's state vector.</p> <code>eval</code> <p>Compute the system's state derivative.</p> See also <p>LinearModel:     Implements a linear time-invariant state-space model.</p> Notes <p>A generic, nonlinear state-space model describes the relations between inputs and ouputs using     nonlinear differential equations of the form:</p> \\[ \\dot{x}(t) = f(x(t), u(t), t) \\] \\[ y(t) = g(x(t), u(t), t) \\] <p>where \\(x(t)\\) is the system's state vector, \\(u(t)\\) is its input vector, \\(y(t)\\) is the output vector, and     t is the time variable. f(.) represents the state equations, while g(.) stands for the output equations.</p> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def __init__(self, \n             initial_state: np.ndarray, \n             initial_control: np.ndarray, \n             state_update_fcn: callable, \n             state_output_fcn: callable, \n             input_dim: int, \n             output_dim: int,\n             input_labels: list[str] | None=None, \n             output_labels: list[str] | None=None) -&gt; None:\n\n    \"\"\"\n    Class constructor.\n    \"\"\"\n\n    super().__init__(initial_state, input_dim, output_dim, input_labels, output_labels);\n    self.state_equations = state_update_fcn;\n    self.output_equations = state_output_fcn;\n    self.u = self._control_type_checks(initial_control);\n\n    return;\n</code></pre>"},{"location":"API_ref/models/state_space/nonlinear/#pynamics.models.state_space_models.NonlinearModel.eval","title":"<code>eval(t, x)</code>","text":"<p>Compute the system's state derivative.</p> <p>This method computes the system's state derivative via the state         equation: \\(\\dot{x} = f(x(t), u(t), t)\\), where \\(x(t)\\) is the state vector,         \\(u(t)\\) is the input vector, \\(t\\) is the time instant, and \\(f(.)\\) are the state equations.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time instant. Used for compatibility reasons. Unused by this method.</p> required <code>x</code> <code>ndarray</code> <p>The current state vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The system's state derivative.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the state function.\n&gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n...\n...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n...     state_derivative_2 = state[1] + control[0];\n...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n...\n...     return state_derivative;   \n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the output function.\n&gt;&gt;&gt; def output_function(state: np.ndarray):\n...\n...     output = np.array([state[0]**state[1]]);\n...\n...     return output;\n&gt;&gt;&gt;\n&gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n&gt;&gt;&gt; \n&gt;&gt;&gt; model.eval(t=0.0, x=model.get_state())\narray([[2.08060461],\n       [2.        ]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def eval(self, t: float, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute the system's state derivative.\n\n    This method computes the system's state derivative via the state \\\n    equation: $\\dot{x} = f(x(t), u(t), t)$, where $x(t)$ is the state vector, \\\n    $u(t)$ is the input vector, $t$ is the time instant, and $f(.)$ are the state equations.\n\n    Parameters\n    ----------\n    t : float\n        Time instant. Used for compatibility reasons. Unused by this method.\n\n    x : np.ndarray\n        The current state vector.\n\n    Returns\n    -------\n    np.ndarray\n        The system's state derivative.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the state function.\n    &gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n    ...\n    ...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n    ...     state_derivative_2 = state[1] + control[0];\n    ...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n    ...\n    ...     return state_derivative;   \n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the output function.\n    &gt;&gt;&gt; def output_function(state: np.ndarray):\n    ...\n    ...     output = np.array([state[0]**state[1]]);\n    ...\n    ...     return output;\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; model.eval(t=0.0, x=model.get_state())\n    array([[2.08060461],\n           [2.        ]])\n    \"\"\"\n\n    return self.state_equations(x, self.u, t);\n</code></pre>"},{"location":"API_ref/models/state_space/nonlinear/#pynamics.models.state_space_models.NonlinearModel.get_input","title":"<code>get_input()</code>","text":"<p>Access the system's input.</p> <p>This method can be use to access the current input vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current input vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the state function.\n&gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n...\n...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n...     state_derivative_2 = state[1] + control[0];\n...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n...\n...     return state_derivative;   \n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the output function.\n&gt;&gt;&gt; def output_function(state: np.ndarray):\n...\n...     output = np.array([state[0]**state[1]]);\n...\n...     return output;\n&gt;&gt;&gt;\n&gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), 2.5 * np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.get_input()\narray([[2.5]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def get_input(self) -&gt; np.ndarray:\n    \"\"\"\n    Access the system's input.\n\n    This method can be use to access the current input vector.\n\n    Returns\n    -------\n    np.ndarray\n        Current input vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the state function.\n    &gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n    ...\n    ...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n    ...     state_derivative_2 = state[1] + control[0];\n    ...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n    ...\n    ...     return state_derivative;   \n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the output function.\n    &gt;&gt;&gt; def output_function(state: np.ndarray):\n    ...\n    ...     output = np.array([state[0]**state[1]]);\n    ...\n    ...     return output;\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), 2.5 * np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.get_input()\n    array([[2.5]])\n    \"\"\"\n\n    return self.u;\n</code></pre>"},{"location":"API_ref/models/state_space/nonlinear/#pynamics.models.state_space_models.NonlinearModel.get_output","title":"<code>get_output()</code>","text":"<p>Compute the system's output from the current state vector.</p> <p>This method can be used to compute the output of a nonlinear state-space         model from its current state vector. This is done by computing         \\(y = g(x(t), u(t), t)\\), where \\(y(t)\\) is the output vector, \\(x(t)\\) is the state vector,         \\(u(t)\\) is the input vector, \\(t\\) is the time instant, and \\(g(.)\\) represents the output equations.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Output vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the state function.\n&gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n...\n...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n...     state_derivative_2 = state[1] + control[0];\n...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n...\n...     return state_derivative;   \n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the output function.\n&gt;&gt;&gt; def output_function(state: np.ndarray):\n...\n...     output = np.array([state[0]**state[1]]);\n...\n...     return output;\n&gt;&gt;&gt;\n&gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), np.zeros((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.get_output()\narray([[1.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def get_output(self) -&gt; np.ndarray:\n    \"\"\"\n    Compute the system's output from the current state vector.\n\n    This method can be used to compute the output of a nonlinear state-space \\\n    model from its current state vector. This is done by computing \\\n    $y = g(x(t), u(t), t)$, where $y(t)$ is the output vector, $x(t)$ is the state vector, \\\n    $u(t)$ is the input vector, $t$ is the time instant, and $g(.)$ represents the output equations.\n\n    Returns\n    -------\n    np.ndarray\n        Output vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the state function.\n    &gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n    ...\n    ...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n    ...     state_derivative_2 = state[1] + control[0];\n    ...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n    ...\n    ...     return state_derivative;   \n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the output function.\n    &gt;&gt;&gt; def output_function(state: np.ndarray):\n    ...\n    ...     output = np.array([state[0]**state[1]]);\n    ...\n    ...     return output;\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), np.zeros((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.get_output()\n    array([[1.]])\n    \"\"\"\n\n    return self.output_equations(self.x);\n</code></pre>"},{"location":"API_ref/models/state_space/nonlinear/#pynamics.models.state_space_models.NonlinearModel.get_state","title":"<code>get_state()</code>","text":"<p>Access the system's state.</p> <p>This method allows one to access the current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Current state vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the state function.\n&gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n...\n...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n...     state_derivative_2 = state[1] + control[0];\n...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n...\n...     return state_derivative;   \n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the output function.\n&gt;&gt;&gt; def output_function(state: np.ndarray):\n...\n...     output = np.array([state[0]**state[1]]);\n...\n...     return output;\n&gt;&gt;&gt;\n&gt;&gt;&gt; model = NonlinearModel(np.zeros((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.get_state()\narray([[0.],\n       [0.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def get_state(self) -&gt; np.ndarray:\n    \"\"\"\n    Access the system's state.\n\n    This method allows one to access the current state vector.\n\n    Returns\n    -------\n    np.ndarray\n        Current state vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the state function.\n    &gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n    ...\n    ...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n    ...     state_derivative_2 = state[1] + control[0];\n    ...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n    ...\n    ...     return state_derivative;   \n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the output function.\n    &gt;&gt;&gt; def output_function(state: np.ndarray):\n    ...\n    ...     output = np.array([state[0]**state[1]]);\n    ...\n    ...     return output;\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model = NonlinearModel(np.zeros((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.get_state()\n    array([[0.],\n           [0.]])\n    \"\"\"\n\n    return self.x;\n</code></pre>"},{"location":"API_ref/models/state_space/nonlinear/#pynamics.models.state_space_models.NonlinearModel.set_input","title":"<code>set_input(u)</code>","text":"<p>Pass a new set of inputs (references, control actions, etc.) to the system.</p> <p>This method can be used to update the system's input vector directly.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray | float</code> <p>The new set of inputs (i.e. input vector).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the state function.\n&gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n...\n...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n...     state_derivative_2 = state[1] + control[0];\n...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n...\n...     return state_derivative;   \n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the output function.\n&gt;&gt;&gt; def output_function(state: np.ndarray):\n...\n...     output = np.array([state[0]**state[1]]);\n...\n...     return output;\n&gt;&gt;&gt;\n&gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), 2.5 * np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.get_input()\narray([[2.5]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.set_input(np.array([[5.0]]));\n&gt;&gt;&gt; model.get_input();\narray([[5.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def set_input(self, u: np.ndarray | float) -&gt; None:\n    \"\"\"\n    Pass a new set of inputs (references, control actions, etc.) to the system.\n\n    This method can be used to update the system's input vector directly.\n\n    Parameters\n    ----------\n    u : np.ndarray | float\n        The new set of inputs (i.e. input vector).\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the state function.\n    &gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n    ...\n    ...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n    ...     state_derivative_2 = state[1] + control[0];\n    ...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n    ...\n    ...     return state_derivative;   \n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the output function.\n    &gt;&gt;&gt; def output_function(state: np.ndarray):\n    ...\n    ...     output = np.array([state[0]**state[1]]);\n    ...\n    ...     return output;\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), 2.5 * np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.get_input()\n    array([[2.5]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.set_input(np.array([[5.0]]));\n    &gt;&gt;&gt; model.get_input();\n    array([[5.]])\n    \"\"\"\n\n    self.u = self._control_type_checks(u);\n\n    return;\n</code></pre>"},{"location":"API_ref/models/state_space/nonlinear/#pynamics.models.state_space_models.NonlinearModel.update_state","title":"<code>update_state(state)</code>","text":"<p>Assign new values to the system's state vector.</p> <p>This method can be used to update the system's state vector directly.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ndarray</code> <p>New state vector.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the state function.\n&gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n...\n...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n...     state_derivative_2 = state[1] + control[0];\n...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n...\n...     return state_derivative;   \n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define the output function.\n&gt;&gt;&gt; def output_function(state: np.ndarray):\n...\n...     output = np.array([state[0]**state[1]]);\n...\n...     return output;\n&gt;&gt;&gt;\n&gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n&gt;&gt;&gt; \n&gt;&gt;&gt; model.get_state()\narray([[1.],\n       [1.]])\n&gt;&gt;&gt;\n&gt;&gt;&gt; model.update_state(np.zeros((2, 1)));\n&gt;&gt;&gt; model.get_state()\narray([[0.],\n       [0.]])\n</code></pre> Source code in <code>pynamics/models/state_space_models.py</code> <pre><code>def update_state(self, state: np.ndarray) -&gt; None:\n    \"\"\"\n    Assign new values to the system's state vector.\n\n    This method can be used to update the system's state vector directly.\n\n    Parameters\n    ----------\n    state : np.ndarray\n        New state vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pynamics.models.state_space_models import NonlinearModel\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the state function.\n    &gt;&gt;&gt; def state_function(state: np.ndarray, control: np.ndarray, time: float):\n    ...\n    ...     state_derivative_1 = state[0] + 2 * np.cos(state[1]);\n    ...     state_derivative_2 = state[1] + control[0];\n    ...     state_derivative = np.array([state_derivative_1, state_derivative_2]);\n    ...\n    ...     return state_derivative;   \n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Define the output function.\n    &gt;&gt;&gt; def output_function(state: np.ndarray):\n    ...\n    ...     output = np.array([state[0]**state[1]]);\n    ...\n    ...     return output;\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model = NonlinearModel(np.ones((2, 1)), np.ones((1, 1)), state_function, output_function, input_dim=2, output_dim=1);\n    &gt;&gt;&gt; \n    &gt;&gt;&gt; model.get_state()\n    array([[1.],\n           [1.]])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; model.update_state(np.zeros((2, 1)));\n    &gt;&gt;&gt; model.get_state()\n    array([[0.],\n           [0.]])\n    \"\"\"\n\n    self.x = state;\n\n    return;\n</code></pre>"}]}